# Многопоточка VZuev

**Оглавление:**
   
1. [Процесс и поток](#process_and_thread)
2. [Квантование времени выполнения потоков](#kvant_time_execute)
3. [Создание и старт потока](#create_and_start_thread)
4. [Методы sleep() и join()](#sleep_and_join_methods)
5. [Состония потоков](#thread_states)
6. [Прерывание потоков](#thread_stop)
7. [Приоритеты потоков](#priority)


### <p id='process_and_thread'>1. Процесс и поток</p>
![02.0_thread.png](02.0_thread.png)
- Процесс - это дорогостоящая операция и для нее ОС выделяет свою мамять под каждый процесс и память этих процессов не пересекается.
- Поток - это более легковесные сущности, которые создаются внутри процессов. Потоки врутри процесса взаимодействуют с одной и 
тойже памятью, которая была выделена процессу

### <p id='kvant_time_execute'>2. Квантование времени выполнения потоков</p>
![03.0_kvantTimeExecute.png](03.0_kvantTimeExecute.png)
Представим, что у нас одно ядро процессора. 

Тогда проц будет выделять по очереди какой-то квант времени каждому потоку на выполнение. 
Таким образом ядро будто прыгаем межде потоками и выполняет их по немногу
![03.1_kvantTimeExecute.png](03.1_kvantTimeExecute.png)
Но если у нас 2 ядра, то они действительно будут выполняться параллельно. Если сбда добавить еще один поток, 
то одно ядро снова начнет прышать между потоками

### <p id='create_and_start_thread'>3. Создание и старт потока</p>
- при старте main() неявно создается поток с именем main
- все последующие потоки отпочковываются от потока main
- Потоки можно создавать своим каким-то классом унаследовавшись от Thread.class. Но если нигде этот класс больше не юзается, 
лучше анонимным классом. Thread наследует функциональный интерфейс Runnable, который содержит в себе метод run()
- для запуска потока юзать start() - thread.start(); Это нужно, чтоб код метода run() запустился в другом потоке

### <p id='sleep_and_join_methods'>4. Методы sleep() и join()</p>
- Задача: просуммировать числа от одного до 1000. При этом числа от 1 до 500 будет считать один поток, а от 501 до 1000 другой.

![04.1_sleepAndJoin.png](04.1_sleepAndJoin.png)
Реализуя код мы получили то, что main закончил выполнение раньше, чем другие потоки и дам над результат НОЛЬ, т.к. 
работы по рассчету шли в других потоках и они не успели посчитать (Runner_4#method_1)

![04.2_sleepAndJoin.png](04.2_sleepAndJoin.png)
Теперь мы добавили слиппер, который отсановил поток main на 1 секунду, тем самым другие потоки успели выполнить свои расчеты

![04.3_sleepAndJoin.png](04.3_sleepAndJoin.png)
join() останавливает работу текущего потока, пока поток, на котором он был вызван не будет выполнен. 
Т.е. мы ставим thread-0.join() находясь в потоке main и поток main ждет пока не будут выполнены все потоки, которые были 
вызваны на нем с .join
Перегруженный метод join(timeout) - тут мы укажем максимальное количество милисекунд, сколько мы согласны ждать.

### <p id='thread_states'>5. Состония потоков</p>
![05.1_threadStates.png](05.1_threadStates.png)
Сотояния потоков определеятся енамом State, который лежит в Thread. Получить состояние потока можно вызвав getState() на потоке

![05.2_threadStates.png](05.2_threadStates.png)
- NEW - состояние потока, который уже создан через new но еще не был запущен
- RUNNABLE - состояение потока, который был запущен методом start() и выполняется сейчас
- BLOCKED - рассмотрим позже, когда будем говорить о мониторах/блокировках
- WAITING - На этом занятии мы будем его делать при помощи join() - какой-то поток будет ждать выполнения другого
но можно еще Thread.wait() от Object
- TIMED_WAITING - можно при помощи sleep(), join(timeout), тот же wait(timeout)
- TERMINATED - если поток завершил свою работу - run() просто все сделал либо из-за необработанного исключения выброшенного 
из метода run(), которое тож прекратит работу потока. Нужно обратить внимание: что если исключение убъет какой-то поток, другие 
продолжат работать!

### <p id='thread_stop'>6. Прерывание потоков</p>
Поток можно прервать, если это нужно
thread.stop() - прервет выполнение потока. Но этот метод deprecated, т.к. нельзя просто так взять и прибить каким-то
потоком другой поток. Но мы можем попросить какой-то поток завершится.
thread.interrupt() - выставит значение isInterrupted для целевого потока в true. Затем выполняя проверку на целевом
потоке по свойству isInterrupted() можно писать логику, чтоб он завершал свою работу. 

Например:

     final Thread communicatingThread = new Thread(() -> {
            try {
                while (!Thread.currentThread().isInterrupted()) {
                    doRequest();
                }

            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        });

    Этот код выполняется до тех пор, пока из другого потока, ему не изменят свойство isInterrupted() вызвав на 
    этом потоке communicatingThread.interrupt();

Не всегда можно запросить на потоке свойство isInterrupted(), т.к. поток может быть заблокирован, например, 
обрабатывает запрос или тот самый метод sleep(). Тут и приходит на помощь исключение InterruptedException - 
блокирующие вызовы прерываются при его помощи.

Представим, что мы отлавливаем это исключение и продолжаем работу потока. Тогда как нам узнать, что поток был прерван?
Thread.interrupted() - проверяет, был ли прерван текущий поток. Более того, вызов этого метода приводит, что это 
свойство устанавливается в false
а вот
Thread.isInterrupted() - можно использовать просто для проверки, был ли прерван текущий поток и поле он не изменяет

Так как правильно обрабатывать отловленное исключение InterruptedException? Т.к. извне мы не сможем узнать, был ли
поток прерван, т.к. мы отловили исключение. И по запросу isInterrupted() мы получим false.
Просто в блоке catch нужно руками проставить это свойство на потоке - currentThread.interrupt() - выставит поле в true

     final Thread communicatingThread = new Thread(() -> {
            while (true) {
                try {
                    doRequest();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    System.out.println(Thread.currentThread().isInterrupted());
                    System.out.println(THREAD_WAS_INTERRUPTED);
                }
            }
        });

### <p id='priority'>7. Приоритеты потоков</p>
- Если много потоков будет находится в состоянии ожидания, то планировцик потоков запустит поток с бОльшим приоритетом. 
Представим что есть много потоков с высоким приоритетом и несколько с маленьким. Может выйти так, что потоки с малым приоритетом 
никогда не будут запущены. Лучшей практикой считается использовать приоритеты по умолчанию и не изменять их. 
Приоритет потоков это числа от 1(min) до 10(max) или универсальными константами из класса Thread:
- > MIN_PRIORITY
- > NORM_PRIORITY 
- > MAX_PRIORITY
  
![06.1_threadPriority.png](06.1_threadPriority.png)
Обычный приоритет это приоритет - 5. По умолчанию, поток наследует приоритетет потока от которого он был создан.
Напомню, что при запуске программы у нас неявно создался поток main с дефолтным приоритетом 5. 
- от main мы отпочковали поток_0 и изменили ему приоритет на 10. От поток_0 отпочковали поток_2 и 2й получил приоритет родителя.
Отпочковали от main поток_1 который получил от родителя приоритет 5.
- Если создать поток с приоритетом меньше 1 или больше 10 - IllegalArgException

