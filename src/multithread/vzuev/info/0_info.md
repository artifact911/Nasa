# Многопоточка VZuev

**Оглавление:**
   
1. [Процесс и поток](#processAndThread)
2. [Квантование времени выполнения потоков](#kvantTimeExecute)
3. [Создание и старт потока](#createAndStartThread)
4. [Методы sleep() и join()](#sleepAndJoinMethods)
5. [Состония потоков](#threadStates)


### <p id='processAndThread'>1. Процесс и поток</p>
![02.0_thread.png](02.0_thread.png)
- Процесс - это дорогостоящая операция и для нее ОС выделяет свою мамять под каждый процесс и память этих процессов не пересекается.
- Поток - это более легковесные сущности, которые создаются внутри процессов. Потоки врутри процесса взаимодействуют с одной и 
тойже памятью, которая была выделена процессу

### <p id='kvantTimeExecute'>2. Квантование времени выполнения потоков</p>
![03.0_kvantTimeExecute.png](03.0_kvantTimeExecute.png)
Представим, что у нас одно ядро процессора. 

Тогда проц будет выделять по очереди какой-то квант времени каждому потоку на выполнение. 
Таким образом ядро будто прыгаем межде потоками и выполняет их по немногу
![03.1_kvantTimeExecute.png](03.1_kvantTimeExecute.png)
Но если у нас 2 ядра, то они действительно будут выполняться параллельно. Если сбда добавить еще один поток, 
то одно ядро снова начнет прышать между потоками

### <p id='createAndStartThread'>3. Создание и старт потока</p>
- при старте main() неявно создается поток с именем main
- все последующие потоки отпочковываются от потока main
- Потоки можно создавать своим каким-то классом унаследовавшись от Thread.class. Но если нигде этот класс больше не юзается, 
лучше анонимным классом. Thread наследует функциональный интерфейс Runnable, который содержит в себе метод run()
- для запуска потока юзать start() - thread.start(); Это нужно, чтоб код метода run() запустился в другом потоке

### <p id='sleepAndJoinMethods'>4. Методы sleep() и join()</p>
- Задача: просуммировать числа от одного до 1000. При этом числа от 1 до 500 будет считать один поток, а от 501 до 1000 другой.

![04.1_sleepAndJoin.png](04.1_sleepAndJoin.png)
Реализуя код мы получили то, что main закончил выполнение раньше, чем другие потоки и дам над результат НОЛЬ, т.к. 
работы по рассчету шли в других потоках и они не успели посчитать (Runner_4#method_1)

![04.2_sleepAndJoin.png](04.2_sleepAndJoin.png)
Теперь мы добавили слиппер, который отсановил поток main на 1 секунду, тем самым другие потоки успели выполнить свои расчеты

![04.3_sleepAndJoin.png](04.3_sleepAndJoin.png)
join() останавливает работу текущего потока, пока поток, на котором он был вызван не будет выполнен. 
Т.е. мы ставим join() на поток main и поток main ждет пока не будут выполнены все потоки, которые были вызваны на нем.
Перегруженный метод join(timeout) - тут мы укажем максимальное количество милисекунд, сколько мы согласны ждать.

### <p id='threadStates'>5. Состония потоков</p>
![05.1_threadStates.png](05.1_threadStates.png)
Сотояния потоков определеятся енамом State, который лежит в Thread. Получить состояние потока можно вызвав getState() на потоке

![05.2_threadStates.png](05.2_threadStates.png)
- NEW - состояние потока, который уже создан через new но еще не был запущен
- RUNNABLE - состояение потока, который был запущен методом start() и выполняется сейчас
- BLOCKED - рассмотрим позже, когда будем говорить о мониторах/блокировках
- WAITING - На этом занятии мы будем его делать при помощи join() - какой-то поток будет ждать выполнения другого
но можно еще Thread.wait() от Object
- TIMED_WAITING - можно при помощи sleep(), join(timeout), тот же wait(timeout)
- TERMINATED - если поток завершил свою работу - run() просто все сделал либо из-за необработанного исключения выброшенного 
из метода run(), которое тож прекратит работу потока. Нужно обратить внимание: что если исключение убъет какой-то поток, другие 
продолжат работать!